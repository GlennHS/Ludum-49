<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <style>
      body {
        display: flex;
        justify-content: center;
      }
    </style>
  </head>
  <body onload="loadGame();">
    <canvas id="canvas" width="1000" height="560"></canvas>
    <script type="application/javascript">
      // #region Global Variables
      // Canvas
      const canvas = document.getElementById("canvas");
      let context = canvas.getContext('2d');
      let canvasWidth = canvas.offsetWidth;
      let canvasHeight = canvas.offsetHeight;
      let gameWindowContents = [];
      let requestingRepaint = false;
      let lastClickPos, lastElemClicked;

      let boardSize = 8;
      let boardDimension = 400;
      let tokenSize = boardDimension / boardSize;

      // Colors
      const colorP1 = '#B3B4B4';
      const colorP2 = '#FAC62F';
      const colorP3 = '#EB2C26';
      const colorP4 = '#24F554';
      const colorP5 = '#8BF7F4';
      // #endregion

      // #region Utility Functions
      const clearWindow = () => context.clearRect(0, 0, canvasWidth, canvasHeight);

      const clearGameWindowContents = () => gameWindowContents = [];

      const getElementClicked = (canvas, event) => {
        let [xPos, yPos] = getCursorPosition(canvas, event);
        let elemClicked;
        gameWindowContents.forEach( obj => {
          try {
            if(typeof obj.width != "undefined" && typeof obj.height != "undefined" && typeof obj.x != "undefined" && typeof obj.y != "undefined") {
              if(obj.x < xPos && xPos < (obj.x + obj.width) && obj.y < yPos && yPos < (obj.y + obj.height)) {
                elemClicked = obj;
              }
            }
          } catch(e) { console.error(e); }
        })
        return elemClicked || false;
      }

      const getCursorPosition = (canvas, event) => {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        return [x, y];
      }

      const checkIsGameObject = (gameObject) => {
        return gameObject.width && gameObject.height && gameObject.x && gameObject.y;
      }

      const getCenter = (gameObject) => {
        if(checkIsGameObject(gameObject)) {
          return [gameObject.x + (gameObject.width / 2), gameObject.y + (gameObject.height / 2)]
        }
      }

      const getColorComplement = (colorString) => {
        switch (colorString) {
          case colorP1, colorP2, colorP4, colorP5:
            return "#000000";
          default:
            return "#FFFFFF";
        }
      }

      // Attach event listeners to canvas
      canvas.addEventListener('mousedown', function(e) {
        // debugger;
        lastClickPos = getCursorPosition(canvas, e);
        lastElemClicked = getElementClicked(canvas, e);
        if(lastElemClicked) {
          lastElemClicked.click();
        }
      })
      // #endregion

      // #region Classes

      /**
       * Main parent class for all window game objects
       * Pseudo-abstract (should never be called but is inherited from. Can't actually do this in JS I think)
       */
      class GameObject {

        constructor(x, y, width, height, onclick) {
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
          this.onclick = onclick;
        }

        click() { this.onclick && this.onclick(); }

        dispose() { gameWindowContents.splice(gameWindowContents.indexOf[this], 1); }
      }

      class Button extends GameObject {

        constructor(x, y, width, height, text, color, onclick) {
          super(x, y, width, height, onclick)
          this.text = text;
          this.color = color;
          this.onclick = onclick;

          gameWindowContents.push(this)
        }

        getOptimumFontSize() {
          const fontSizes = [11, 12, 14, 16, 18, 24, 32, 48, 64];
          const idealFontSize = this.height / 2;
          let validFontSizes = fontSizes.filter((s) => s > idealFontSize);
          return validFontSizes.length > 0 ? validFontSizes[0] : fontSizes[fontSizes.length - 1];
        }

        draw() {
          context.beginPath();
          context.rect(this.x, this.y, this.width, this.height);
          context.fillStyle = this.color;
          context.fill();
          context.closePath();

          context.lineJoin = 'bevel';
          context.lineWidth = 25;
          context.strokeStyle = this.color;
          context.strokeRect(this.x, this.y, this.width, this.height);

          const optimumFontSize = this.getOptimumFontSize();
          context.font = `${optimumFontSize}px Arial`;
          context.fillStyle = getColorComplement(this.color);
          context.textAlign = "center";
          let [centerX, centerY] = getCenter(this);
          context.fillText(this.text, centerX, centerY + optimumFontSize / 3);
        }
      }

      class Token extends GameObject {

        constructor(x, y, type, onclick) {
          super(x, y, tokenSize, tokenSize, onclick);
          this.type = type;

          gameWindowContents.push(this)
        }

        changePos(newPos) {
          [this.x, this.y] = newPos;
        }

        getImg() {
          let img = new Image();
          switch (this.type) {
            case "N":
              img.src = "assets\\gif\\nitris-token.gif";

            case "E":
              img.src = "assets\\gif\\etherium-token.gif";

            case "S":
              img.src = "assets\\gif\\sardinite-token.gif";

            case "W":
              img.src = "assets\\gif\\wearine-token.gif";

            default:
              img.src = "assets\\gif\\nitris-token.gif";
          }
          return img;
        }

        draw() {
          let img = this.getImg();
          context.drawImage(img, this.x, this.y, tokenSize, tokenSize);
        }
      }

      class Board extends GameObject {

        constructor(x, y, width, height, boardState, onclick) {
          super(x, y, width, height, onclick);
          this.boardState = boardState || this.generateNewBoard();

          gameWindowContents.push(this)
        }

        generateNewBoard() {
          let boardOut = [];
          for(let i = 0; i < boardSize; i++) {
            let row = [];
            for(let j = 0; j < boardSize; j++) {
              let tokenToAdd = new Token(this.x + i * tokenSize, this.y + j * tokenSize, 'NESW'.split("")[Math.floor(Math.random() * 4)], function() {
                console.log(`Token Clicked, type is ${this.type}`);
                requestingRepaint = true;
              })
              row.push(tokenToAdd)
              gameWindowContents.push(tokenToAdd)
            }
            boardOut.push(row);
          }
          // debugger;
          return boardOut;
        }

        draw() {
          context.lineJoin = 'miter';
          context.lineWidth = 5;
          context.strokeStyle = colorP1;
          context.strokeRect(this.x, this.y, this.width, this.height);
        }
      }
      // #endregion

      const loadGame = () => {
        drawMainMenu();
        window.requestAnimationFrame(redraw)
      }

      const redraw = () => {
        if(requestingRepaint) {
          clearWindow();
          gameWindowContents.forEach( obj => {
            typeof obj.draw != "undefined" ?  obj.draw() : false;
          })
          requestingRepaint = false;
          // debugger;
        }
        window.requestAnimationFrame(redraw);
      }

      const drawMainMenu = () => {
        clearGameWindowContents();
        clearWindow();
        let btnPlay = new Button(200,160, 600, 60, "PLAY", colorP5, drawGameWindow);
        let btnOptions = new Button(200, 260, 600, 60, "OPTIONS", colorP5, drawGameWindow);
        let btnAbout = new Button(200,360, 600, 60, "ABOUT", colorP5, drawGameWindow);
        let btnExit = new Button(200,460, 600, 60, "EXIT", colorP3, drawGameWindow);
        requestingRepaint = true;
      }

      const drawGameWindow = () => {
        clearWindow();
        clearGameWindowContents();
        const board = new Board(50, 50, 400, 400, undefined, undefined)
        requestingRepaint = true;
      }
    </script>
  </body>
</html>
