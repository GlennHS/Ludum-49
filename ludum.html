<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <style>
      body {
        display: flex;
        justify-content: center;
      }
    </style>
  </head>
  <body onload="loadGame();">
    <canvas id="canvas" width="1240" height="700"></canvas>
    <script type="application/javascript">
      // #region Global Variables
      // Canvas
      const canvas = document.getElementById("canvas");
      let context = canvas.getContext('2d');
      let canvasWidth = canvas.offsetWidth;
      let canvasHeight = canvas.offsetHeight;
      let gameWindowContents = [];
      let currentWindow = "MENU" // MENU || GAME || UPGRADE ||
      let requestingRepaint = false;
      let lastClickPos, lastElemClicked;
      let gifFrameBufferMax = 5;
      let gifFrameBuffer = gifFrameBufferMax;

      let boardSize = 8;
      let boardDimension = 600;
      let tokenGap = 8;
      let tokenSize = Math.floor(boardDimension / boardSize) - tokenGap;

      // Colors
      const colorP1 = '#B3B4B4';
      const colorP2 = '#FAC62F';
      const colorP3 = '#EB2C26';
      const colorP4 = '#24F554';
      const colorP5 = '#8BF7F4';
      // #endregion

      // #region Utility Functions
      const clearWindow = () => context.clearRect(0, 0, canvasWidth, canvasHeight);

      const clearGameWindowContents = () => gameWindowContents = [];

      const getElementClicked = (canvas, event) => {
        let [xPos, yPos] = getCursorPosition(canvas, event);
        let elemClicked;
        gameWindowContents.forEach( obj => {
          try {
            if(typeof obj.width != "undefined" && typeof obj.height != "undefined" && typeof obj.x != "undefined" && typeof obj.y != "undefined" && typeof obj.onclick != "undefined") {
              if(obj.x < xPos && xPos < (obj.x + obj.width) && obj.y < yPos && yPos < (obj.y + obj.height)) {
                elemClicked = obj;
              }
            }
          } catch(e) { console.error(e); }
        })
        return elemClicked || false;
      }

      const getCursorPosition = (canvas, event) => {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        return [x, y];
      }

      const checkIsGameObject = (gameObject) => {
        return gameObject.width && gameObject.height && gameObject.x && gameObject.y;
      }

      const getCenter = (gameObject) => {
        if(checkIsGameObject(gameObject)) {
          return [gameObject.x + (gameObject.width / 2), gameObject.y + (gameObject.height / 2)]
        }
      }

      const getColorComplement = (colorString) => {
        switch (colorString) {
          case colorP1, colorP2, colorP4, colorP5:
            return "#000000";
          default:
            return "#FFFFFF";
        }
      }

      // Attach event listeners to canvas
      canvas.addEventListener('mousedown', function(e) {
        // debugger;
        lastClickPos = getCursorPosition(canvas, e);
        lastElemClicked = getElementClicked(canvas, e);
        if(lastElemClicked) {
          // debugger;
          lastElemClicked.click();
        }
      })
      // #endregion

      // #region Classes

      /**
       * Main parent class for all window game objects
       * Pseudo-abstract (should never be called but is inherited from. Can't actually do this in JS I think)
       */
      class GameObject {

        constructor(x, y, width, height, onclick) {
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
          this.onclick = onclick;
        }

        click() { this.onclick && this.onclick(); }

        dispose() { gameWindowContents.splice(gameWindowContents.indexOf[this], 1); }

        clear() { context.clearRect(this.x, this.y, this.width, this.height); }
      }

      class Button extends GameObject {

        constructor(x, y, width, height, text, color, onclick) {
          super(x, y, width, height, onclick)
          this.text = text;
          this.color = color;
          this.onclick = onclick;

          gameWindowContents.push(this)
        }

        getOptimumFontSize() {
          const fontSizes = [11, 12, 14, 16, 18, 24, 32, 48, 64];
          const idealFontSize = this.height / 2;
          let validFontSizes = fontSizes.filter((s) => s > idealFontSize);
          return validFontSizes.length > 0 ? validFontSizes[0] : fontSizes[fontSizes.length - 1];
        }

        draw() {
          context.beginPath();
          context.rect(this.x, this.y, this.width, this.height);
          context.fillStyle = this.color;
          context.fill();
          context.closePath();

          context.lineJoin = 'bevel';
          context.lineWidth = 25;
          context.strokeStyle = this.color;
          context.strokeRect(this.x, this.y, this.width, this.height);

          const optimumFontSize = this.getOptimumFontSize();
          context.font = `${optimumFontSize}px Arial`;
          context.fillStyle = getColorComplement(this.color);
          context.textAlign = "center";
          let [centerX, centerY] = getCenter(this);
          context.fillText(this.text, centerX, centerY + optimumFontSize / 3);
        }
      }

      class Token extends GameObject {

        constructor(x, y, type, onclick) {
          super(x, y, tokenSize, tokenSize, onclick);
          this.type = type;
          this.frameNum = 0;
          this.maxFrames = type == "E" ? 8 : type == "T" ? 12 : 16;

          gameWindowContents.push(this)
          requestingRepaint = true;
        }

        changePos(newPos) {
          [this.x, this.y] = newPos;
        }

        incrementFrame() {
          this.frameNum++;
          if(this.frameNum > this.maxFrames - 1) { this.frameNum -= this.maxFrames; }
        }

        getImgSrc() {
            switch (this.type) {
              case "N":
                return `assets\\spritesheets\\nitris-token\\nitris-token_${this.frameNum}.png`;
  
              case "E":
                return `assets\\spritesheets\\etherium-token\\etherium-token_${this.frameNum}.png`;
  
              case "S":
                return `assets\\spritesheets\\sardinite-token\\sardinite-token_${this.frameNum}.png`;
  
              case "W":
                return `assets\\spritesheets\\wearine-token\\wearine-token_${this.frameNum}.png`;
  
              case "T":
                return `assets\\spritesheets\\time-token\\time-token_${this.frameNum}.png`;
  
              default:
                return "assets\\gif\\nitris-token.gif";
            }
        }

        draw() {
          let src = this.getImgSrc();
          let img = new Image(tokenSize, tokenSize);
          img.onload = () => {
            this.clear();
            context.drawImage(img, this.x, this.y);
          }
          img.src = src;
          this.incrementFrame();
        }

        static generateRandomTokenWithXY(x, y) {
          const tokenTypes = 'NESWT'.split("");
          const chosenType = tokenTypes[Math.floor(Math.floor(Math.random() * 17) / 4)]; // Designed to skew against Time Tokens
          const tokenOnclick = function() {
              console.log(`Token Clicked, type is ${this.type}`);
          }
          return new Token(x, y, chosenType, tokenOnclick);
        }
      }

      class Board extends GameObject {

        constructor(x, y, boardState, onclick) {
          super(x, y, boardDimension, boardDimension, onclick);
          this.boardState = boardState || this.generateNewBoard();

          gameWindowContents.push(this)
          requestingRepaint = true;
        }

        generateNewBoard() {
          const fullTokenSize = tokenSize + tokenGap;
          let boardOut = [];
          for(let i = 0; i < boardSize; i++) {
            let row = [];
            for(let j = 0; j < boardSize; j++) {
              let xPos = this.x + j * fullTokenSize + (tokenGap / 2); // Need to add a bit of tokenGap otherwise it clips frame
              let yPos = this.y + i * fullTokenSize + (tokenGap / 2); // Swapped i & j so it generates row by row instead of col by col
              let tokenToAdd = Token.generateRandomTokenWithXY(xPos, yPos);
              row.push(tokenToAdd)
            }
            boardOut.push(row);
          }
          return boardOut;
        }

        draw() {
          context.lineJoin = 'miter';
          context.lineWidth = 5;
          context.strokeStyle = colorP1;
          context.strokeRect(this.x, this.y, this.width, this.height);
        }
      }
      // #endregion

      const loadGame = () => {
        drawMainMenu();
        window.requestAnimationFrame(redraw)
      }

      const redraw = () => {
        if(requestingRepaint) {
          // clearWindow();
          requestingRepaint = false;
          gameWindowContents.forEach( obj => {
            // typeof obj.clear != "undefined" ?  obj.clear() : false;
            typeof obj.draw != "undefined" ?  obj.draw() : false;
          })
          // debugger;
        }
        gifFrameBuffer--;
        if(gifFrameBuffer <= 0) {
          requestingRepaint = true;
          gifFrameBuffer = gifFrameBufferMax;
        }
        window.requestAnimationFrame(redraw);
      }

      const drawMainMenu = () => {
        currentWindow = "MENU"
        clearGameWindowContents();
        clearWindow();
        let btnPlay = new Button(200,160, 600, 60, "PLAY", colorP5, drawGameWindow);
        let btnOptions = new Button(200, 260, 600, 60, "OPTIONS", colorP5, drawGameWindow);
        let btnAbout = new Button(200,360, 600, 60, "ABOUT", colorP5, drawGameWindow);
        let btnExit = new Button(200,460, 600, 60, "EXIT", colorP3, drawGameWindow);

        requestingRepaint = true;
      }

      const drawGameWindow = () => {
        currentWindow = "GAME"
        clearWindow();
        clearGameWindowContents();
        const board = new Board(25, 25, undefined, undefined)
        
        requestingRepaint = true;
      }
    </script>
  </body>
</html>
